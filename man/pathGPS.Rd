% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/columnEstimator.R
\name{pathGPS}
\alias{pathGPS}
\title{pathGPS}
\usage{
pathGPS(
  beta = "metabolites",
  UV = NULL,
  graph = NULL,
  p,
  p0,
  r,
  envr.subtract = TRUE,
  sprs.transform = TRUE,
  aggregate = TRUE,
  returnFull = FALSE,
  parameters = list()
)
}
\arguments{
\item{beta}{full marginal association estimates, either a string or a matrix of dimension number of SNPs x number of phenotypes. If \code{beta} is "metabolites", the metabolites data is used; if \code{beta} is "biobank", the UK biobank data is used. If \code{beta} is a matrix, each row should stand for a SNP, each column should stand for a phenotype, and the value should be the marginal association estimate of the corresponding SNP, phenotype pair. SNPs should be ranked in decreasing order of their relevance to the set of phenotypes. The top \code{p} rows will be used as signal SNPs and the last \code{p0} rows will be used as noise SNPs.}

\item{p}{the number of signal SNPs.}

\item{p0}{the number of noise SNPs.}

\item{r}{the number of eigen-vectors preserved in the truncated eigen-decomposition.}

\item{envr.subtract}{a logical value. If \code{TRUE}, environmental effects are estimated using noise SNPs and subtracted from genetic effects in signal SNPs. Default is \code{TRUE}.}

\item{sprs.transform}{a logical value. If \code{TRUE}, estimated eigen-vectors are linearly transformed to be sparser using \code{varimax} or \code{promax} from factor analysis. Hyperparameters for \code{varimax} and \code{promax} can be provided to \code{parameters}. Default is \code{TRUE}.}

\item{aggregate}{a logical value. If \code{TRUE}, bootstrap aggregation is applied to stabilize the method. Hyperparameters for bootstrap aggregation can be provided to \code{parameters}. Default is \code{TRUE}.}

\item{returnFull}{whether to return UHatList and VHatList. TODO!!!}

\item{parameters}{a list of hyperparameters.
\itemize{
\item \code{sprs.transform.m}: the power of the target used by \code{promax} if \code{sprs.transform} is \code{TRUE}. If \code{sprs.transform.m} is one, \code{varimax} is used. If \code{sprs.transform.m} is larger than one, \code{promax} is used with \code{sprs.transform.m}. Default is 1.
\item \code{U.prop.zero}: proportion of zeros in U's columns. For each column of U, we truncate the bottom \code{U.prop.zero} elements ranked by absolute values to zero. Default is 0.8.
\item \code{V.prop.zero}: proportion of zeros in V's columns. For each column of V, we truncate the bottom \code{V.prop.zero} elements ranked by absolute values to zero. Default is 0.8.
\item \code{aggregate.method}: method for aggregation if \code{aggregate} is \code{TRUE}. If \code{aggregate.method} is "bootstrap", SNPs are bootstrapped for aggregation. If \code{aggregate.method} is "subsample", SNPs are subsampled without replacement and the subsample size is determined by \code{subsample.p}. Default is "bootstrap".
\item \code{n.aggregate}: the number of aggregation samples. Default is 100.
\item \code{subsample.p}: subsample ratio if \code{aggregate.method} is "subsample". Default is 0.8.
\item \code{randomSeed}: random seed used in aggregation. Default is NULL.
\item \code{kU}: the number of genotypes in each genotype-phenotype cluster without aggregation. Default is the number of signal SNPs divided by 2\code{r}.
\item \code{kV}: the number of phenotypes in each genotype-phenotype cluster without aggregation. Default is the number of phenotypes divided by 2\code{r}.
\item \code{gg.weight}: weight of (genotype, genotype) pairs in computing co-appearance. Default is 1.
\item \code{gp.weight}: weight of (genotype, phenotype) pairs in computing co-appearance. Default is 1.
\item \code{pp.weight}: weight of (phenotype, phenotype) pairs in computing co-appearance. Default is 1.
\item \code{clustering.method}: method of clustering signal SNPs and phenotypes. If \code{aggregate} is \code{FALSE}, \code{clustering.method} is ignored and the i-th cluster consists of phenotypes and genotypes with non-zero elements in the i-th column of V and U, respectively.  If \code{aggregate} is \code{TRUE}, \code{clustering.method} currently takes the following options: if \code{clustering.method} equals "UMAP", we use \code{UMAP} to find two-dimensional embeddings of signal SNPs and use \code{kmeans} cluster the embeddings; if \code{clustering.method} equals "tSNE", we use \code{tSNE} to find two-dimensional embeddings of signal SNPs and phenotypes and use \code{kmeans} cluster the embeddings; if \code{clustering.method} equals "spectral", we use co-appearance as the kernel function and use spectral clustering to cluster signal SNPs and phenotypes. Hyperparameters for clustering can be further provided to \code{parameters}. Default is "UMAP".
\item \code{max.coappearance}: the upper bound of co-appearance weight. The distance induced by co-appearance is defined as max.coappearance - co-appearance. Default is the larger of 1/\code{r} and the maximal co-appearance.
\item \code{tSNE.perplexity}: TODO!!!
\item \code{UMAP.n_neighbors}: TODO!!!
\item \code{rsnps_results}: TODO!!!
\item \code{description}: TODO!!!
\item \code{pValue}: TODO!!!
\item \code{coappearance.truncate}: TODO!!!
}}

\item{X}{covariate matrix to predict conditional densities at; each row represents an observation vector.}
}
\value{
VHat, UHat
}
\description{
estimate the row space of V (#mediators x #phenotypes) and the column space of U (#genotypes x #mediators)
}
